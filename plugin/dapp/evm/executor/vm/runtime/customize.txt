package runtime

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/33cn/chain33/account"
	"github.com/33cn/chain33/common/address"
	//"github.com/33cn/plugin/plugin/dapp/evm/executor/abi"
	"github.com/33cn/plugin/plugin/dapp/evm/executor/vm/common"
	"github.com/33cn/plugin/plugin/dapp/evm/executor/vm/params"
	"github.com/ethereum/go-ethereum/accounts/abi"
	ecommon "github.com/ethereum/go-ethereum/common"
	"math/big"
	"strings"
)

// StatefulPrecompiledContract is the interface for executing a precompiled contract
// This wraps the PrecompiledContracts native to Ethereum and allows adding in stateful
// precompiled contracts to support native chain33 asset transfers.
type StatefulPrecompiledContract interface {
	RequiredGas(input []byte) uint64
	Run(evm *EVM, caller ContractRef, input []byte) (ret []byte, err error)
}

//CustomizePrecompiledContractsBinjiang ...
//因为common.Address结构体中定义的是指针，map中的key值不能使用address作为key值来使用，于是使用Hash160Address作为key来进行索引
var CustomizePrecompiledContractsBinjiang = map[common.Hash160Address]StatefulPrecompiledContract{
	//0x01-0x08 是evm 系统自带的预编译合约接口，自定义预编译合约接口从0x1000 开始
	common.BytesToHash160Address([]byte{129}): &evm2Exchange{},
	//从 exchange 到evm
	common.BytesToHash160Address([]byte{130}): &exchange2Evm{},
	//查询exchange balance
	common.BytesToHash160Address([]byte{131}): &exchangeBalance{},
}

type evm2Exchange struct {
}

func (e *evm2Exchange) RequiredGas(input []byte) uint64 {
	gas := uint64(len(input)+31)/32*params.IdentityPerWordGas + params.IdentityBaseGas
	fmt.Println("evm2Exchange-------------->gas:", gas)
	return 50000
}

func (e *evm2Exchange) Run(evm *EVM, caller ContractRef, input []byte) ([]byte, error) {
	fmt.Println("evm2Exchange-------------->precompile")
	// step 1 对input 数据进行解析 transfer
	if len(input) < 40 {
		return nil, errors.New("input size to low")
	}
	assertSymbol := string(bytes.TrimSpace(input[:20]))
	contractorAddr := common.BytesToAddress(input[20:40])
	fmt.Println("contractorAddrrrrrrrr", contractorAddr.String(), "assertSymbol", assertSymbol, "<end>")

	fmt.Println("evm2Exchange--------------> assertSymbol new:", assertSymbol)
	abiobj, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		fmt.Println("evm2Exchange-------------->precompile JSON:", err)
		return nil, err
	}

	method, ok := abiobj.Methods["transfer"]
	if !ok {
		return nil, errors.New("no this method")
	}
	params, err := method.Inputs.Unpack(input[44:])
	if err != nil {
		fmt.Println("evm2Exchange-------------->precompile Unpack:", err)
		return nil, err
	}
	recipient := params[0].(ecommon.Address)
	amount, _ := params[1].(*big.Int)
	fmt.Println("outparam", params)
	//input: assertContractaddress(20 bytes)|packdata
	//evm合约地址，把币转移到某个地址下托管
	fmt.Println("evm2Exchange-------------->precompile ---->recipient", recipient.String(), "amount:", amount)
	// step2 把evm的币转移到一个托管地址下
	// 在此处打印下自定义合约的错误信息
	if !evm.StateDB.Exist(contractorAddr.String()) {
		return nil, errors.New("contract not exist")
	}
	contract := NewContract(caller, AccountRef(contractorAddr), 0, e.RequiredGas(input[40:]))
	contract.SetCallCode(&contractorAddr, evm.StateDB.GetCodeHash(contractorAddr.String()), evm.StateDB.GetCode(contractorAddr.String()))
	//lock evm assert
	fmt.Println("codeHash:", evm.StateDB.GetCodeHash(contractorAddr.String()))
	ret, err := evm.Interpreter.Run(contract, input[40:], false) //lock/tuoguan
	if err != nil {
		return nil, err
	}

	// step3  给exchange account 账户 增加对应的余额
	receipt, err := evm.MStateDB.TransferToExchange(recipient.String(), assertSymbol, amount.Int64())
	if err != nil {
		return nil, err
	}
	fmt.Println("evm2Exchange.Run receipt------>", receipt, "key:", string(receipt.KV[0].GetKey()), "logs", string(receipt.GetLogs()[0].GetLog()))
	return ret, nil

}

type exchange2Evm struct {
}

func (e *exchange2Evm) RequiredGas(input []byte) uint64 {
	return uint64(len(input)+31)/32*params.IdentityPerWordGas + params.IdentityBaseGas
}
func (e *exchange2Evm) Run(evm *EVM, caller ContractRef, input []byte) ([]byte, error) {
	if len(input) < 40 {
		return nil, errors.New("input size to low")
	}
	assertSymbol := string(input[:20])
	contractorAddr := common.BytesToAddress(input[20:40])
	//unlock
	abiobj, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		fmt.Println("evm2Exchange-------------->precompile JSON:", err)
		return nil, err
	}

	method, ok := abiobj.Methods["transfer"]
	if !ok {
		return nil, errors.New("no this method")
	}

	outParam, err := method.Inputs.Unpack(input[44:])
	if err != nil {
		return nil, err
	}
	recipient := outParam[0].(common.Address)
	amount, _ := outParam[1].(*big.Int)
	fmt.Println("recipientttttttttttt", recipient.String())
	if !evm.StateDB.Exist(recipient.String()) {
		return nil, errors.New("contract not exist")
	}
	contract := NewContract(caller, AccountRef(contractorAddr), amount.Uint64(), e.RequiredGas(input[20:]))
	contract.SetCallCode(&contractorAddr, evm.StateDB.GetCodeHash(contractorAddr.String()), evm.StateDB.GetCode(contractorAddr.String()))
	//unlock evm assert
	ret, err := evm.Interpreter.Run(contract, input[40:], false) //lock/tuoguan
	if err != nil {
		return ret, err
	}
	// step3  给exchange account 账户 增加对应的余额
	receipt, err := evm.MStateDB.WithDrawExchange(recipient.String(), assertSymbol, amount.Int64())
	//(evm, caller.Address().String(), assertSymbol, amount.Int64())
	if err != nil {
		return ret, err
	}
	fmt.Println("receipt", receipt)
	//sep4 transfertoexec exchange
	return ret, nil

}

type exchangeBalance struct {
}

func (e *exchangeBalance) RequiredGas(input []byte) uint64 {
	return 0
}

func (e *exchangeBalance) Run(evm *EVM, caller ContractRef, input []byte) ([]byte, error) {
	if len(input) < 20 {
		return nil, errors.New("input size to low")
	}
	abiobj, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		fmt.Println("evm2Exchange-------------->precompile JSON:", err)
		return nil, err
	}

	method, ok := abiobj.Methods["balanceOf"]
	if !ok {
		return nil, errors.New("no this method")
	}

	outParam, err := method.Inputs.Unpack(input[24:])
	if err != nil {
		return nil, err
	}

	recipient := outParam[0].(ecommon.Address)
	assertSymbol := string(input[:20])
	fmt.Println("recipientttttttttttt", recipient.String(), "assertSymbol:", assertSymbol)
	//evmxgoAccount, err := account.NewAccountDB(evm.StateDB.GetConfig(), "evmxgo", assertSymbol, evm.mStateDB.StateDB)
	evmxgoAccount, err := account.NewAccountDB(evm.cfg, "evmxgo", "usdt", nil)
	if err != nil {
		return nil, err
	}
	fmt.Println("evmxgoAccount:", evmxgoAccount)
	execName := evm.MStateDB.GetConfig().ExecName("exchange")
	execaddress := address.ExecAddress(execName)
	//导出账户地址
	acc, err := evmxgoAccount.LoadExecAccountQueue(evm.MStateDB.GetApi(), recipient.String(), execaddress)
	if err != nil {
		return nil, err
	}

	fmt.Println("exchangeBalance--------->balance", acc.GetBalance(), "addr:", acc.GetAddr())

	return big.NewInt(acc.Balance).Bytes(), nil
}

const ERC20ABI = `[
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "allowance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "recipient",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "transfer",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "recipient",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]`
